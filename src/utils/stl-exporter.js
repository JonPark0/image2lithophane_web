export class STLExporter {
  /**
   * Three.js 지오메트리를 STL 파일로 내보내기
   * @param {THREE.BufferGeometry} geometry - 내보낼 지오메트리
   * @param {string} filename - 파일명
   */
  export(geometry, filename = 'lithophane.stl') {
    const stlString = this.generateSTL(geometry)
    this.download(stlString, filename)
  }

  /**
   * Binary STL 생성
   */
  generateSTL(geometry) {
    const positions = geometry.attributes.position.array
    const indices = geometry.index ? geometry.index.array : null

    let triangles
    if (indices) {
      triangles = indices.length / 3
    } else {
      triangles = positions.length / 9
    }

    // Binary STL 포맷
    const bufferLength = 84 + triangles * 50
    const buffer = new ArrayBuffer(bufferLength)
    const view = new DataView(buffer)

    // Header (80 bytes)
    const header = 'Generated by Image to Lithophane Converter'
    for (let i = 0; i < 80; i++) {
      view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0)
    }

    // Number of triangles
    view.setUint32(80, triangles, true)

    let offset = 84

    // Triangles
    if (indices) {
      for (let i = 0; i < indices.length; i += 3) {
        const i1 = indices[i] * 3
        const i2 = indices[i + 1] * 3
        const i3 = indices[i + 2] * 3

        const v1 = [positions[i1], positions[i1 + 1], positions[i1 + 2]]
        const v2 = [positions[i2], positions[i2 + 1], positions[i2 + 2]]
        const v3 = [positions[i3], positions[i3 + 1], positions[i3 + 2]]

        const normal = this.calculateNormal(v1, v2, v3)

        // Normal
        view.setFloat32(offset, normal[0], true)
        view.setFloat32(offset + 4, normal[1], true)
        view.setFloat32(offset + 8, normal[2], true)
        offset += 12

        // Vertex 1
        view.setFloat32(offset, v1[0], true)
        view.setFloat32(offset + 4, v1[1], true)
        view.setFloat32(offset + 8, v1[2], true)
        offset += 12

        // Vertex 2
        view.setFloat32(offset, v2[0], true)
        view.setFloat32(offset + 4, v2[1], true)
        view.setFloat32(offset + 8, v2[2], true)
        offset += 12

        // Vertex 3
        view.setFloat32(offset, v3[0], true)
        view.setFloat32(offset + 4, v3[1], true)
        view.setFloat32(offset + 8, v3[2], true)
        offset += 12

        // Attribute byte count (unused)
        view.setUint16(offset, 0, true)
        offset += 2
      }
    } else {
      for (let i = 0; i < positions.length; i += 9) {
        const v1 = [positions[i], positions[i + 1], positions[i + 2]]
        const v2 = [positions[i + 3], positions[i + 4], positions[i + 5]]
        const v3 = [positions[i + 6], positions[i + 7], positions[i + 8]]

        const normal = this.calculateNormal(v1, v2, v3)

        // Normal
        view.setFloat32(offset, normal[0], true)
        view.setFloat32(offset + 4, normal[1], true)
        view.setFloat32(offset + 8, normal[2], true)
        offset += 12

        // Vertices
        for (let j = 0; j < 9; j++) {
          view.setFloat32(offset, positions[i + j], true)
          offset += 4
        }

        // Attribute byte count
        view.setUint16(offset, 0, true)
        offset += 2
      }
    }

    return buffer
  }

  /**
   * 법선 벡터 계산
   */
  calculateNormal(v1, v2, v3) {
    const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]]
    const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]]

    const normal = [
      u[1] * v[2] - u[2] * v[1],
      u[2] * v[0] - u[0] * v[2],
      u[0] * v[1] - u[1] * v[0]
    ]

    const length = Math.sqrt(normal[0] ** 2 + normal[1] ** 2 + normal[2] ** 2)

    if (length > 0) {
      normal[0] /= length
      normal[1] /= length
      normal[2] /= length
    }

    return normal
  }

  /**
   * 파일 다운로드
   */
  download(data, filename) {
    const blob = new Blob([data], { type: 'application/octet-stream' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  }
}
